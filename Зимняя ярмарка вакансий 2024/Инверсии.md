### C. Инверсии

|||
|-------------|---------------|
| Ограничение времени | 8 секунд |
| Ограничение памяти  | 1Gb      |  

Пусть p1, p2, …, pn перестановка чисел от 1 до n. Будем говорить, что пара индексов (i,j) образует инверсию, если i<j и pi>pj.
Задана некоторая перестановка (p1,…,pn), требуется определить среднее количество инверсий в перестановке, полученной из данной после одной перестановки пары элементов. При этом индексы переставляемых элементов выбираются равновероятно среди всех пар различных чисел от 1 до n.

**Формат ввода**  
В первой строке записано одно целое число n (2≤n≤2000).
Во второй строке записаны n целых чисел p1, p2, …, pn (1≤pi≤n), все числа в строке различны.

**Формат вывода**  
Выведите несократимую дробь a∕b, задающую значение среднего числа инверсий по всем возможным парам переставляемых индексов элементов.

|Тестовые данные|Ожидаемый результат|
|-------------|---------------|
| 5 <br> 1 2 3 4 5</br> | 3/1 |
| 3<br>3 1 2</br>  | 5/3      |  
| 7<br>7 4 1 2 3 6 5</br>  | 31/3      |  

```c++
#include <vector>
#include <unordered_map>
#include <iostream>

using namespace std;
//Алгоритм Евклида для нахождения НОД
long long findGCD(long long a, long long b) {
    while (b != 0) {
        long long temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}

int main(int argc, char const *argv[]) {
    int n; cin >> n;
    vector<int> data(n);
    for(int i = 0; i < n; i++) 
        cin >> data[i];
    unordered_map<int, vector<int>> mp;
    long long defaultState = 0; //Число инверсий в исходной строке
    /*
        В цикле делаем что-то похожее на префиксные суммы: на jом индексе считаем число элементов, которых больше iый.
        Пусть есть последовательность:                      3 5 8 9 7 1
        Для числа 7 строка в матрице будет выглядеть так:   3 2 1 1 1 1
    */
    for(int i = 0; i < n; i++) { 
        mp.insert({data[i], vector<int>(n)});
        mp[data[i]][n - 1] = data[i] > data[n - 1];
        for(int j = n - 2; j >= 0; j--) {
            mp[data[i]][j] = mp[data[i]][j + 1] + (data[i] > data[j]);
            if(i == j) defaultState += mp[data[i]][j]; // для подсчета инверсий нас не интересуют числа слева
        }
    }
    /*
        Пример для иллюстрации того, откуда взялись эти формулы:
        Поменяем 4 и 6 местами в последовательности: 4 7 1 2 3 6 5
        Для 4 строка в матрице выглядит вот так:     3 3 3 2 1 0 0
        Для 6 строка в матрице выглядит вот так:     5 4 4 3 2 1 1
        При перемещении слева направо число инверсий уменьшается, а при перемещении справа налево - увеличивается;

        Но так же надо учесть элементы, которые больше тех, которые мы меняем местами:
        Для этого мы находим разницу между {расстоянием переставляемых элементов} 
                                         и {разницей было/стало элементов меньше данного, т е первая половина формулы};
    */
    long long res = 0;
    for(int i = 0; i < n; i++) {
        for(int j = i + 1; j < n; j++) {
            long long l2r = mp[data[i]][j] - mp[data[i]][i] 
            + ((n - 1 - i - mp[data[i]][i]) - (n - 1 - j - mp[data[i]][j]));
            long long r2l = mp[data[j]][i] - mp[data[j]][j] 
            - ((n - 1 - i - mp[data[j]][i]) - (n - 1 - j - mp[data[j]][j]));
            res += defaultState + l2r + r2l;
        }
    }
    long long count = n * (n - 1) / 2;
    long long gcd = findGCD(res, count); 
    cout << (res - count) / gcd << "/" << count / gcd;
    return 0;
}
```
